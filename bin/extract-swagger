#!/usr/bin/env node
'use strict';

/* eslint-disable no-console */
/* crée un fichier destination du meme nom que le fichier source mais dans un répertoire donné en entrée*/
const yaml = require('js-yaml');
const fs = require('fs-extra');
const program = require('commander');
const swaggerToHTML = require('bootprint').load(require('bootprint-openapi'));
const download = require('download-git-repo');
const { extractSwagger, listEndpoints } = require('../');
const searchRecursive = require ('../lib/search-recursive'); //instead use index.js for import


program
  .version('0.1.0')
  .usage('[options] <endpoint> [<endpoint> ...]')
  .option('-s, --src <sourcefile>', 'Source swagger/openapi spec')
  .option('-d, --dest <destDirectory>', 'Generated swagger/openapi spec')
  .option('-h, --html')
    .option('-g, --downnloadgitarchi')
  .parse(process.argv);

const destDirectory =  program.dest;
var repoArchiSourcesDirectory = "tmp";
//add control to not overwrite sourcefile
if (program.src) {
    repoArchiSourcesDirectory= program.src;
}

if (program.downnloadgitarchi) {
    const gitlab = 'direct:http://gitlab.edelia.net/architecture/architecture.git';
    try {
        download(gitlab , repoArchiSourcesDirectory, {clone: true});
    }
    catch (err) {
        console.log(err ? `Error donlaod rapo : ${err}` : `Success download repo ${gitlab}`);
        process.exit();
    }
    // pull if directory exist already
}
//we want directory output existed
fs.mkdirs(destDirectory, function (err) {
    if (err) return console.error(err);
    console.log(`success create directory ${destDirectory}`)
});

var files = searchRecursive(repoArchiSourcesDirectory+"\\"+"systems", '.yaml'); // replace dir and pattern
files.forEach(file => {
    file = file.replace(/\\/g, '\\\\');
   // console.log(file);
    let sourceDoc;
    try {
        sourceDoc = yaml.safeLoad(fs.readFileSync(file, 'utf8'));
        //sourceDoc = yaml.safeLoad(fs.readFileSync("C:\\Mes Documents\\Outils\\node-v10.15.1-win-x64\\node_modules\\extract-swagger-for-endpoints\\bc-elec-api.yaml", 'utf8'));
        //sourceDoc = yaml.safeLoad(fs.readFileSync("C:\\Mes Documents\\Outils\\node-v10.15.1-win-x64\\node_modules\\extract-swagger-for-endpoints\\accreditation-adobe-compaign-extraction-batch.yaml", 'utf8'));
        //sourceDoc = yaml.safeLoad(fs.readFileSync("C:\\Mes Documents\\Outils\\node-v10.15.1-win-x64\\node_modules\\extract-swagger-for-endpoints\\tmp\\systems\\accreditation-sys\\accreditation-adobe-compaign-extraction-batch\\accreditation-adobe-compaign-extraction-batch.yaml", 'utf8'));
    } catch (e) {
        console.log(`erreur de lecture du fichier ${e}`);
        process.exit();
    }
    const destDoc = extractSwagger(sourceDoc, program.args);
    console.log(destDoc);
    if (destDoc) {
        const destRelativeFile = file.substring(file.lastIndexOf("\\"), file.length);
        const destFile = destDirectory + '\\' + destRelativeFile;
//        console.log(`File destination would be : ${destFile}`);
        try {
            fs.writeFileSync(destFile, yaml.safeDump(destDoc, {skipInvalid: true}));
        } catch (e) {
            console.log(e);
            process.exit();
        }
    }
});


if (program.downnloadgitarchi) {
//delete sources of repo archi
    fs.remove(repoArchiSourcesDirectory, function (err) {
        console.log(err ? `Error deleting directory ${repoArchiSourcesDirectory} : ${err}` : `success deleting directory ${repoArchiSourcesDirectory}`)
    });
}

if (program.html) {
    swaggerToHTML.build(destFile, destDirectory).generate().done(console.log)
}